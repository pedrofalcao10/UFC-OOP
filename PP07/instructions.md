# Instruções  

## Visão Geral

Nessa prática de programação, cada questão (descrita em cada passo da próxima seção) deve ser implementada nas classes especificadas. Você deverá escrever testes automatizados para todas as tarefas nos lugares indicados na classe `Main.java`.
   
## Passos

1. Você deverá criar a classe `SIException`  (Exceção de Saldo Insuficiente) no pacote `br.ufc.poo.conta.excecao`. A exceção `SIException` deverá ser levantada (`throw new SIException(...)`) dentro das implementações dos métodos `public void debitar(double valor)` das classes que representam contas bancárias. Nota! Lembre-se que você vai precisar ajustar a assinatura dos métodos envolvidos (`public void debitar(double valor)` das classes de contas) para indicar que eles podem retornar a exceção `SIException`. Além disso, a assinatura de métodos de `IBanco` e `BancoIndependente` deverão ser ajustadas para acomotar esse novo fluxo de exceção (eles devem propagar `SIException`). Ao final, você deverá escrever um código que teste esse comportamento excepcional dentro do método `public static void testaPasso1()`.

2. Você deverá criar a classe `VNException` (Exceção de Valor Negativo) no pacote `br.ufc.poo.conta.excecao`. A exceção `VNException` deverá ser levantada (`throw new VNException(...)`) dentro das implementações dos métodos `public void debitar(double valor)` e `public void creditar(double valor)` das classes que representam contas bancária toda vez que o argumento `double valor` for negativo. A exceção `VNException` deve ter dois atributos internos: `private String numero` e `private double valor`. `VNException` deve possuir um construtor que permita informar o número da conta e o valor negativo da operação: `VNException(String numero, double valor)` e métodos de acesso (`public String getNumero()` e `public double getValor()`). Nota! Lembre-se que você vai precisar ajustar a assinatura dos métodos envolvidos (`public void debitar(double valor)` e `public void creditar(double valor)` das classes de contas) para indicar que eles podem retornar a exceção `VNException`. Além disso, a assinatura de métodos de `IBanco` e `BancoIndependente` deverão ser ajustadas para acomotar esse novo fluxo de exceção (eles devem propagar `VNException`). Ao final, você deverá escrever um código que teste esse comportamento excepcional dentro do método `public static void testaPasso2()`.

3. Você deverá criar a classe `TNPException` (Exceção de Taxa Negativa da Poupanca) no pacote `br.ufc.poo.conta.excecao`. A exceção `TNPException` deverá ser levantada (`throw new TNPException(...)`) dentro da implementação do método `public void renderJuros(double taxa)` da classe `ContaPoupanca` toda vez que o argumento `double taxa` for negativo. A exceção `TNPException` deve ter dois atributos internos: `private String numero` e `private double taxa`. `TNPException` deve possuir um construtor que permita informar o número da conta e o valor negativo da taxa: `VNException(String numero, double taxa)` e métodos de acesso (`public String getNumero()` e `public double getTaxa()`). Nota! Lembre-se que você vai precisar ajustar a assinatura do método envolvido (`public void renderJuros(double taxa)` de `ContaPoupanca`) para indicar que ele pode retornar a exceção `TNPException`. Além disso, a assinatura de métodos de `IBanco` e `BancoIndependente` deverão ser ajustadas para acomotar esse novo fluxo de exceção (eles devem propagar `TNPException`). Ao final, você deverá escrever um código que teste esse comportamento excepcional dentro do método `public static void testaPasso3()`.

4. Você deverá criar a classe `PNBException` (Exceção de Percentagem Negativa do Bonus) no pacote `br.ufc.poo.conta.excecao`. A exceção `PNBException` deverá ser levantada (`throw new PNBException(...)`) dentro da implementação do método `public void setBonusPercentagem(double percentagem)` da classe `ContaEspecial` toda vez que o argumento `double percentagem` for negativo. A exceção `PNBException` deve ter dois atributos internos: `private String numero` e `private double percentagem`. `PNBException` deve possuir um construtor que permita informar o número da conta e o valor negativo da percentagem: `PNBException(String numero, double percentagem)` e métodos de acesso (`public String getNumero()` e `public double getPercentagem()`). Nota! Lembre-se que você vai precisar ajustar a assinatura do método envolvido (`public void setBonusPercentagem(double percentagem)` de `ContaEspecial`) para indicar que ele pode retornar a exceção `PNBException`. Além disso, a assinatura de métodos de `IBanco` e `BancoIndependente` deverão ser ajustadas para acomotar esse novo fluxo de exceção (eles devem propagar `PNBException`). Ao final, você deverá escrever um código que teste esse comportamento excepcional dentro do método `public static void testaPasso4()`.

5. Você deverá criar a classe `TNIException` (Exceção de Taxa Negativa do Imposto) no pacote `br.ufc.poo.conta.excecao`. A exceção `TNIException` deverá ser levantada (`throw new TNIException(...)`) dentro da implementação do método `public void setTaxa(double taxa)` da classe `ContaImposto` toda vez que o argumento `double taxa` for negativo. A exceção `TNIException` deve ter dois atributos internos: `private String numero` e `private double taxa`. `TNIException` deve possuir um construtor que permita informar o número da conta e o valor negativo da taxa: `TNIException(String numero, double taxa)` e métodos de acesso (`public String getNumero()` e `public double getTaxa()`). Nota! Lembre-se que você vai precisar ajustar a assinatura do método envolvido (`public void setTaxa(double taxa)` de `ContaImposto`) para indicar que ele pode retornar a exceção `TNIException`. Além disso, a assinatura de métodos de `IBanco` e `BancoIndependente` deverão ser ajustadas para acomotar esse novo fluxo de exceção (eles devem propagar `TNIException`). Ao final, você deverá escrever um código que teste esse comportamento excepcional dentro do método `public static void testaPasso5()`.

6. Você deverá criar a classe `CIException` (Exceção de Conta Inexistente) no pacote `br.ufc.poo.conta.repo.excecao`. A exceção `CIException` deverá ser levantada (`throw new CIException(...)`) dentro das implementações do método `public void remover(String numero)` da interface `IRepositorioConta` nas classes `ArrayConta` e `VectorConta` toda vez que a conta alvo da remoção não exista no repositório. A exceção `CIException` deve ter o seguinte atributo interno: `private String numero`. `CIException` deve possuir um construtor que permita informar o número da conta: `CIException(String numero)` e método de acesso (`public String getNumero()`). Nota! Lembre-se que você vai precisar ajustar a assinatura dos métodos envolvidos (`public void remover(String numero)` de `IRepositorioConta`, `ArrayConta` e `VectorConta`) para indicar que eles podem retornar a exceção `CIException`. Além disso, a assinatura de métodos de `IBanco` e `BancoIndependente` deverão ser ajustadas para acomotar esse novo fluxo de exceção (eles devem propagar `CIException`). Ao final, você deverá escrever um código que teste esse comportamento excepcional dentro do método `public static void testaPasso6()`.

7. Você deverá criar a classe `CEException` (Exceção de Conta Existente) no pacote `br.ufc.poo.conta.repo.excecao`. A exceção `CEException` deverá ser levantada (`throw new CEException(...)`) dentro das implementações do método `public void inserir(ContaAbstrata conta)` da interface `IRepositorioConta` nas classes `ArrayConta` e `VectorConta` toda vez que a conta alvo da insersão já exista no repositório (i.e., já exista uma conta cadastrada no repositório com o mesmo número). A exceção `CEException` deve ter o seguinte atributo interno: `private String numero`. `CEException` deve possuir um construtor que permita informar o número da conta: `CEException(String numero)` e método de acesso (`public String getNumero()`). Nota! Lembre-se que você vai precisar ajustar a assinatura dos métodos envolvidos (`public void inserir(ContaAbstrata conta)` de `IRepositorioConta`, `ArrayConta` e `VectorConta`) para indicar que eles podem retornar a exceção `CEException`. Além disso, a assinatura de métodos de `IBanco` e `BancoIndependente` deverão ser ajustadas para acomotar esse novo fluxo de exceção (eles devem propagar `CEException`). Ao final, você deverá escrever um código que teste esse comportamento excepcional dentro do método `public static void testaPasso7()`.

8. Você deverá criar a classe `TIException` (Exceção de Transferência Invália) no pacote `br.ufc.poo.banco.excecao`. A exceção `TIException` deverá ser levantada (`throw new TIException(...)`) dentro das implementações do método `public void transferir(String origem, String destino, double valor)` da interface `IBanco` na classe `BancoIndependente` toda vez que uma exceção do tipo `CIException`, `SIException` ou `VNException` for propagada. A exceção `TIException` deve possuir um construtor que permita informar a causa da exceção (a exceção que causou o problema): `TIException(Throwable cause)` (esssa causa deve ser passada para construtor da superclasse chamando `super(cause)` como primeira instrução do construtor). Nota! Lembre-se que você vai precisar ajustar a assinatura dos métodos envolvidos (`public void transferir(String origem, String destino, double valor)` de `IBanco` e `BancoIndependente`) para indicar que eles podem retornar a exceção `TIException`. OBS. o método `public void transferir(String origem, String destino, double valor)` só deve indicar a sinalização de uma única exceção: `TIException`.  Ao final, você deverá escrever um código que teste esse comportamento excepcional dentro do método `public static void testaPasso8()`.
